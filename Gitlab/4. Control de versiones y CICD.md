
## II. Fase de Control de Versiones y Dockerfile de Producción

Una vez que la aplicación funciona localmente, preparamos el repositorio y creamos la imagen que se usará en producción (más optimizada que la de Sail).

### 1. Inicialización de Git y Subida a GitLab

1. **Inicializa Git y realiza el primer _commit_:**
    
    Bash
    
    ```
    git init
    git add .
    git commit -m "feat: configuracion inicial de laravel con sail"
    ```
    
2. Conecta con GitLab:
    
    Añade tu repositorio remoto y haz el push a la rama principal (main).
    
    Bash
    
    ```
    git remote add origin git@tu-gitlab.com:tu-usuario/hola-laravel.git
    git push -u origin main
    ```
    

### 2. Creación del Dockerfile de Producción

Crea el archivo **`Dockerfile`** en la **raíz** del proyecto (`hola-laravel/`). Este es un _multi-stage build_ optimizado para el CI/CD.

Dockerfile

```
# 1. ETAPA DE CONSTRUCCIÓN (Instala dependencias)
FROM composer:2.7 as vendor
WORKDIR /app
COPY composer.json composer.lock ./
RUN composer install --no-dev --optimize-autoloader --no-interaction

# 2. ETAPA DE PRODUCCIÓN (Imagen ligera con PHP-FPM y Nginx)
FROM php:8.3-fpm-alpine

# Instalar extensiones y Nginx
RUN apk add --no-cache nginx libzip-dev \
    && docker-php-ext-install pdo pdo_mysql opcache bcmath zip \
    && rm -rf /var/cache/apk/*

# Copiar código y dependencias
COPY . /var/www/html/
COPY --from=vendor /app/vendor /var/www/html/vendor

# Configuración de Nginx
COPY ./docker/nginx/default.conf /etc/nginx/http.d/default.conf

# Permisos
USER www-data
RUN chown -R www-data:www-data /var/www/html/storage /var/www/html/bootstrap/cache \
    && chmod -R 775 /var/www/html/storage /var/www/html/bootstrap/cache
WORKDIR /var/www/html

EXPOSE 80
CMD sh -c "nginx && php-fpm"
```

### 3. Configuración de Nginx

Crea la carpeta `docker/nginx/` y el archivo **`docker/nginx/default.conf`** para que Nginx sepa servir Laravel:

Nginx

```
server {
    listen 80;
    root /var/www/html/public;

    index index.php index.html;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        fastcgi_pass 127.0.0.1:9000;
        fastcgi_index index.php;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        include fastcgi_params;
    }
}
```

---

## III. Fase de Despliegue (GitLab CI/CD)

### 1. Configuración de Variables Secretas en GitLab

En **Settings > CI/CD > Variables**, debes añadir estas variables **antes** de lanzar el pipeline.

|Key|Value (Ejemplo)|Tipo|Descripción|
|---|---|---|---|
|**SSH_USER**|`deploy_user`|Variable|Usuario Linux en el servidor remoto.|
|**SSH_HOST**|`tuservidor.com`|Variable|IP o dominio del servidor de despliegue.|
|**SSH_PRIVATE_KEY**|**Contenido de tu clave privada SSH**|**File**|Clave SSH que usará el GitLab Runner. (Debes haber añadido la clave **pública** al `authorized_keys` del servidor remoto).|

### 2. El Pipeline: Archivo `.gitlab-ci.yml`

Crea el archivo **`.gitlab-ci.yml`** en la **raíz** para definir las etapas de _Build_ (construcción) y _Deploy_ (despliegue).

YAML

```
stages:
  - build
  - deploy

# ----------------------------------------------------
# 1. BUILD: Construir la imagen y subirla al Registry de GitLab
# ----------------------------------------------------
build_image:
  stage: build
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  variables:
    DOCKER_TLS_CERTDIR: "/certs"
  
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY
    - IMAGE_TAG=$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA
    - docker build -t $IMAGE_TAG .
    - docker push $IMAGE_TAG
  only:
    - main

# ----------------------------------------------------
# 2. DEPLOY: Conectarse al servidor remoto vía SSH y actualizar el contenedor
# ----------------------------------------------------
deploy_production:
  stage: deploy
  image: alpine/git
  
  before_script:
    - apk update && apk add openssh-client docker-cli
    - eval $(ssh-agent -s)
    - echo "$SSH_PRIVATE_KEY" | tr -d '\r' | ssh-add - > /dev/null
    - mkdir -p ~/.ssh && chmod 700 ~/.ssh
    - ssh-keyscan $SSH_HOST >> ~/.ssh/known_hosts && chmod 644 ~/.ssh/known_hosts
  
  script:
    - echo "Iniciando despliegue de $CI_COMMIT_SHORT_SHA en $SSH_HOST..."
    
    # Comando SSH (ejecutado en el servidor remoto)
    - SSH_COMMAND="
        export CI_REGISTRY_USER=\"$CI_REGISTRY_USER\";
        export CI_REGISTRY_PASSWORD=\"$CI_REGISTRY_PASSWORD\";
        export IMAGE_TAG=\"$CI_REGISTRY_IMAGE:$CI_COMMIT_SHORT_SHA\";
        
        # 1. Login y Pull (descarga la nueva imagen)
        docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $CI_REGISTRY;
        docker pull $IMAGE_TAG;

        # 2. Detener y eliminar el contenedor antiguo
        if docker ps -a | grep -q 'laravel-hola'; then
            docker stop laravel-hola && docker rm laravel-hola;
        fi;

        # 3. Crear el nuevo contenedor (Asume que .env está en el servidor)
        docker run -d \
            --name laravel-hola \
            -p 80:80 \
            -v /ruta/del/.env:/var/www/html/.env \
            $IMAGE_TAG;
    "
    # Ejecuta el comando en el servidor
    - ssh $SSH_USER@$SSH_HOST "$SSH_COMMAND"

  environment:
    name: production
    url: http://$SSH_HOST
  only:
    - main
```

### 3. Ejecución Final

Haz _commit_ de los nuevos archivos (`Dockerfile`, `docker/nginx/default.conf`, y `.gitlab-ci.yml`) y haz _push_ a la rama `main` en GitLab. El pipeline se iniciará automáticamente, construirá la imagen y desplegará tu aplicación "Hola Laravel" en el servidor remoto.